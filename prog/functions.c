#include <stdio.h>
#include <stdlib.h>
#include "header.h"

void input_int_var(int* a, int min, int max)																		// функция ввода и проверки целых чисел с условием
{
	int check = 0;
	if (min == 0 && max == 0)
	{	
		while (check != 1)	                                                                                        // цикл ввода и проверки
		{
			printf("Введите размерность квадратной матрицы (целое десятичное число): ");							// вывод сообщения с описанием вводимой величины
			check = scanf("%d", a);								                                                	// ввод значения
			if (check != 1)														                                    // проверка правильности типа введённого значения
				printf("\033[1;31mОшибка ввода: не целое десятичное число, попробуйте ввести еще раз.\033[0m\n");   // вывод сообщения об ошибке
			rewind(stdin);														                                    // очистка буфера ввода
		}
	}
	else
	{
		while (check != 1)																											// цикл ввода и проверки
		{
			printf("Выберите способ ввода значений матрицы: \n\t\033[1;36m1\033[0m для ручного ввода\n\t\033[1;36m2\033[0m для заполнения натуральными числами\n\t\033[1;36m3\033[0m для заполнения рандомными значениями\n");
			printf("Введите целое десятичное число в диапазоне от %d до %d: ", min, max);											// вывод сообщения с описанием вводимой величины
			check = scanf("%d", a);																									// ввод значения
			if (check != 1)																											// проверка правильности типа введённого значения
				printf("\033[1;31mОшибка ввода: не целое десятичное число, попробуйте ввести еще раз.\033[0m\n");					// вывод сообщения об ошибке
			if (*a < min || *a > max)
			{
				printf("\033[1;31mОшибка ввода: число не находится в указанном диапазоне, попробуйте ввести еще раз.\033[0m\n");	// вывод сообщения об ошибке
				check = 0;
			}
			rewind(stdin);																											// очистка буфера ввода
		}
	}
}

void input_double_var(double* a)																							// функция ввода и проверки вещественных чисел
{
	int check = 0;
	while (check != 1)	                                                                                                    // цикл ввода и проверки
	{
		printf("Введите действительное десятичное число: ");					                                            // вывод сообщения с описанием вводимой величины
		check = scanf("%lf", a);								                                                            // ввод значения
		if (check != 1)														                                                // проверка правильности типа введённого значения
			printf("\033[1;31mОшибка ввода : не действительное десятичное число, попробуйте ввести еще раз.\033[0m\n");     // вывод сообщения об ошибке
		rewind(stdin);														                                                // очистка буфера ввода
	}
}

double** matrix_memory_alloc(int n)								// функция выделения памяти для двумерного динамического массива
{
	double** array = (double**)calloc(n, sizeof(double*));		// выделение памяти
	if (array == NULL)											// обработка неправильного выделения памяти
	{					
		printf("\033[1;31mОшибка выделения памяти.\033[0m\n");
		return 0;
	}
	for (int i = 0; i < n; i++)
	{											
		*(array + i) = (double*)calloc(n, sizeof(double));	// выделение памяти для строк
	if (*(array + i) == NULL)								// обработка неправильного выделения памяти
	{
		printf("\033[1;31mОшибка выделения памяти.\033[0m\n");
		matrix_memory_free(array, n);
		return 0;
	}
	}
	return array;
}

void input_matrix(double** array, int n, int choise)		// функция ввода значений двумерного динамического массива
{
	switch (choise)
	{
	case 1:													// ввод вручную
		printf("Введите значения матрицы\n");
		for (int i = 0; i < n; i++)							// цикл по строкам
		{
			for (int j = 0; j < n; j++)						// цикл по столбцам
			{
				printf("Строка \033[1;36m%d\033[0m | столбец \033[1;36m%d\033[0m\n", i, j);
				input_double_var(*(array + i) + j);
			}
		}
		break;
	case 2:													// заполнение натуральными числами
		printf("Заполнение матрицы натуральными числами\n");
		for (int i = 0; i < n; i++)							// цикл по строкам
		{
			for (int j = 0; j < n; j++)						// цикл по столбцам
			{
				*(*(array + i) + j) = i * n + j + 1;
			}
		}
		break;
	case 3:													// заполнение случайными числами
		printf("Заполнение матрицы случайными числами\n");
		for (int i = 0; i < n; i++)							// цикл по строкам
		{
			for (int j = 0; j < n; j++)						// цикл по столбцам
			{
				*(*(array + i) + j) = ((double)rand() / RAND_MAX) * RAND_MAX / 100;
			}
		}
		break;
	default:
		break;
	}
	
}

void matrix_memory_free(double** array, int n)      // функция освобождения памяти матрицы
{
	for (int i = 0; i < n; i++)						// цикл по строкам
	{
		free(*(array + i));							// освобождение памяти строки
	}
	free(array);									// освобождение памяти матрицы

}

void change_matrix(double** matrix, int n)			// функция изменения положения элементов матрицы
{ 
	
	double** temp = matrix_memory_alloc(n);			// Выделение памяти для temp

	
	for (int i = 0; i < n; i++)                     // Копирование элементов из matrix в temp
	{
		for (int j = 0; j < n; j++) 
		{
			*(*(temp + i) + j) = *(*(matrix + i) + j);
		}
	}

													// Перенос элементов из temp обратно в matrix в порядке по спирали
	int index = 0;									// индекс перебора элементов temp
	int left = 0, right = n - 1;					// индексы границ записи в matrix
	int top = 0, bottom = n - 1;					// индексы границ записи в matrix

	while (left <= right && top <= bottom)			// цикл записи элементов temp в matrix по спирали
	{
		for (int i = left; i <= right; i++)         // заполнение верхней строки слева направо
		{
			*(*(matrix + top) + i) = *(*(temp + index / n) + index % n);
			index++;
		}
		top++;

		for (int i = top; i <= bottom; i++)         // заполнение правого столбца сверху вниз
		{
			*(*(matrix + i) + right) = *(*(temp + index / n) + index % n);
			index++;
		}
		right--;

		if (top <= bottom)                          // заполнение нижней строки справа налево (если она еще есть)
		{
			for (int i = right; i >= left; i--)
			{
				*(*(matrix + bottom) + i) = *(*(temp + index / n) + index % n);
				index++;
			}
			bottom--;
		}

		if (left <= right)                          // заполнение левого столбца снизу вверх (если он еще есть)
		{
			for (int i = bottom; i >= top; i--)
			{
				*(*(matrix + i) + left) = *(*(temp + index / n) + index % n);
				index++;
			}
			left++;
		}
	}

	
	matrix_memory_free(temp, n);					// Освобождение памяти, выделенной для временного массива temp
}

void output_matrix(double** array, int n, int t)	// функция вывода двухмерного массива
{
	switch (t)
	{
	case 1 :
		printf("Матрица \033[1;36mдо\033[0m сортировки: \n\n");
		break;
	case 2 :
		printf("Матрица \033[1;36mпосле\033[0m сортировки: \n\n");
		break;
	default:
		break;
	}

	for (int i = 0; i < n; i++)                     // цикл по строкам
	{
		for (int j = 0; j < n; j++)                 // цикл по строкам
		{
			printf("\t%.2lf", *(*(array + i) + j)); // вывод элемента матрицы в консоль
		}
		printf("\n\n");                             
	}
}

void restart_program(int* flag)																					// функция перезапуска программы
{
	printf("Для завершения работы программы введите \033[1;32m0\033[0m, иначе перезапуск программы.\n");	    // запрос на перезапуск программы 
	scanf("%d", flag);																							// ввод значения флага цикла программы
	if (flag != 0)																								// проверка значения флага
		printf("Перезапуск программы...\n");																	// вывод сообщения о перезапуске программы
	else
		printf("Завершение работы...\n");																		// вывод сообщения о завершении работы программы
}